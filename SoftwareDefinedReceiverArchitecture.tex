\chapter{GNSS Software Defined Receiver Architecture}
Since 1993, the Global Positioning System (GPS) has provided users with capable hardware to determine their global position within seconds and in recent developments, a centimeter-level position error. GPS can be explained in 3 components: the satellite vehicles in space, control and transmission of signals, and the receiver processing component.

GPS satellites have undergone multiple improvements and upgrades since the first satellites were launched in 1978. These versions of satellites are based on their \textit{block}. Currently, Block III is the most advanced satellite orbiting Earth today. Early versions (Block I) of GPS satellites were used mainly for development and did not transmit signals to the public. Lessons learned from the Block I satellites were fully integrated into the Block II GPS satellites, where GPS became fully operational in 1993. While there were many subtle differences between Block I and Block II satellites, the most important difference is that these new satellites broadcasted a signal on 2 frequencies, coined \textit{L1}, \textit{L2}, and \textit{L2c}, where \textit{L2c} is intended for civilian use. Modern day Block III satellites transmit their signal on the same frequencies that Block II satellites have, with the addition of \textit{L5}. Table provides the frequencies that signals are transmitted on.

\begin{table}[h!]\label{tbl:GPSfreq}
    \centering
    \begin{tabular}{lc}
        \toprule
        \textbf{Name} & \textbf{Frequency [Mhz]} \\
        \midrule
        \textit{L1}   & \(1575.42\)              \\
        \textit{L2}   & \(1227.60\)              \\
        \textit{L2c}  & \(1227.60\)              \\
        \textit{L5}   & \(1176.45\)              \\
        \bottomrule
    \end{tabular}
\end{table}
%% Background/Introduction

\section{Front End}
The signals received by an antenna must be down converted and digitized before the processing of the signal can take place. The \textit{Front End} of the receiver performs this conversion through a series of amplifiers, filters, and a Analog-to-Digital Converter (ADC). First, a signal is received by a Right-Hand Circularly Polarized (RHCP) antenna. The antenna can be passive, but for scenarios where long cables are used, a powered, active antenna may be necessary. Because of the low received signal power that GNSS constellations provide, the signal is amplified through a series of Low Noise Amplifiers (LNA) and Band Pass Filters (BPF). The LNA raise the power of the received GPS signal and the BPF act as a first-step in removing non-GPS signals from processing. The last stage is passing the continuous received signal through the ADC where the signal is converted to digitized samples at a frequency of the receiver-embedded oscillator. The oscillator is filtered using a phase lock loop, described later. Table~\ref{tbl:clocks} provides a description of the clock typically utilized on GNSS hardware receivers.

\begin{table}[!ht]\label{tbl:clocks}
    \caption{Typical clocks embedded on hardware GNSS receivers.}
    \centering
    \begin{tabular}{cccc}
        \toprule
        Name                        & Abbreviation & Application \\
        \midrule
        Oxidized Crystal Oscillator & OCXO         &             \\
        Oxidized Crystal Oscillator & OCXO         &             \\
        Oxidized Crystal Oscillator & OCXO         &             \\
        Oxidized Crystal Oscillator & OCXO         &             \\
        \bottomrule
    \end{tabular}
\end{table}

The purpose in this mixing process is to transform the signal into a more manageable intermediate frequency while still maintaining the same modulation and Doppler applied to the signal. Figure~\ref{fig:frontend} describes the process on converting the analog, continuous signal into a discrete, digitized IF signal in block diagram form.

\begin{figure}[!ht]\label{fig:frontend}
    \centering
    \includegraphics[width=\linewidth]{Figures/frontend.drawio.png}
    \caption{Block diagram of a software defined receiver front end}
\end{figure}

\section{Acquisition}
Once the received signals are converted to a discrete, continuous form, the receiver will determine which satellites are transmitting and in-view. Acquisition correlates local replicas of a signal with the received data. In order for there to be a large correlation magnitude, pseudo-random number (PRN) codes must be within 1-chip and the frequency of the carrier wave must also be within 250 hertz of the true frequency. Correlation with the carrier frequency can be difficult due to the trajectory of the satellite, and even more difficult if the collection perform is also moving. The motion of the satellites with respect to the receiver bring a change to the carrier frequency known as the Doppler shift. For the algorithms in acquisition to successfully determine which satellites are in-view of the receiver, it is beneficial to correlate with each satellite for the specified constellation, at each code offset, and at a wide range of carrier frequency offsets.

A modern, ubiquitous approach to correlating the local replica signals with the received data is using a Parallel Code Phase Search (PCPS) algorithm in which the correlations occur in the frequency domain~\cite{scottRapidSignalAcquisition}. PCPS parallelizes the PRN code offset search space by converting the space from the time to frequency domain. This process is shown in Figure~\ref{fig:PCPS}.

\begin{figure}[!ht]\label{fig:PCPS}
    \centering
    \includegraphics[width=\linewidth]{Figures/PCPS.drawio.png}
    \caption{Block diagram of the PCPS acquisition algorithm applied to GPS L1 C/A signal modulation.}
\end{figure}

To start, the local replicas of the carrier wave are multiplied with the received data across both inphase and quadrature channels in the complex number space. These resulting multiplications are summed together and passed through a Fast-Fourier Transform (FFT) to convert the vectors into the frequency domain. The second step involves converting the PRN codes of the satellites within the specified constellation to the frequency domain and then applying the complex conjugate to frequency-based, PRN vectors. Multiplying the PRN replicas with the transformed carrier replicas provides the user with an auto-correlation in the frequency domain. To appreciate the correlation magnitudes, the output is passed though an Inverse FFT, converting the correlation values from a frequency domain, complex vector to a time domain, real vector. The last step requires squaring the absolute value of this vector and then processing the next satellite until all satellites in the constellation are processed. If a correlation exceeds a certain magnitude, its location in the matrix of correlations indicates the estimated PRN code delay and Doppler shift carrier frequency for that particular satellite. The resolution of the PCPS algorithm greatly depends on the grid of Doppler search bins; for a static receiver processing GPS L1 C/A transmissions, a typical resolution is \(-15,000\) to \(15,000\) Hertz in bins of \(500\) Hertz.

\section{Tracking}
Acquisition provides initial estimates of code delay and carrier frequency for each satellite that is in-view of the receiver. However, because of the motion of the satellites and the receiver (if not static), the delays of the code and changes in the carrier frequencies must continue to be estimated. Tracking performs this process by opening a channel for each in-view satellite. For the duration of the recording, a number of algorithms within tracking continue to correlate the local receiver replica with the received signal data. For scalar tracking, Figure~\ref{fig:scalartracking} describes the flow of how these algorithms produce accurate code replicas for the receiver to calculate satellite PVT solutions.

\begin{figure}[!ht]\label{fig:scalartracking}
    \centering
    \includegraphics[width=0.5\linewidth]{Figures/scalartracking.png}
    \caption{Flow diagram of scalar tracking algorithms.}
\end{figure}

\subsection{Correlators}
For a receiver to know it is replicating the signal correctly, it generates several correlators that are defined by the error in frequency, phase, and code phase between the replicated signal and the received signal data~(Equation~\ref{eq:correlators}).

\begin{equation}\label{eq:correlators}
    \begin{split}
        IP(k) & = A\,R(\epsilon)\,D(k)\,\cos\left(\pi \,f_{err}\,T + \theta_{err}\right) + \eta_{IP}\\
        QP(k) & = A\,R(\epsilon)\,D(k)\,\cos\left(\pi \,f_{err}\,T + \theta_{err}\right) + \eta_{QP}\\
        IE(k) & = A\,R(\epsilon + d)\,D(k)\,\cos\left(\pi \,f_{err}\,T + \theta_{err}\right) + \eta_{IE}\\
        QE(k) & = A\,R(\epsilon + d)\,D(k)\,\cos\left(\pi \,f_{err}\,T + \theta_{err}\right) + \eta_{QE}\\
        IL(k) & = A\,R(\epsilon - d)\,D(k)\,\cos\left(\pi \,f_{err}\,T + \theta_{err}\right) + \eta_{IL}\\
        QL(k) & = A\,R(\epsilon - d)\,D(k)\,\cos\left(\pi \,f_{err}\,T + \theta_{err}\right) + \eta_{QL}\\
    \end{split}
\end{equation}

This correlation process is also referred to as \textit{integration and dump} in the literature as receivers will calculate the different correlators and dump the received signal data for that integration period, \(T\). The integration period is usually set as the number of seconds for a full code cycle. In GPS L1 C/A, \(T\) is \(0.001\) seconds. The amplitude (Equation~\ref{eq:amplitude}) is the measure of received signal power as a function of the integration period, frequency error (\(f_{err}\)), and carrier-to-noise ratio \(\left(\frac{C}{N_0}\right)\).

\begin{equation}\label{eq:amplitude}
    A = \sqrt{2\,T\,\frac{C}{N_0}}\, \frac{\sin\left(\pi \, f_{err} \, T \right)}{\pi \, f_{err} \, T}
\end{equation}

The rest of the terms in Equation~\ref{eq:correlators} are as follows: \(\theta_{err}\) is the phase error, described as the difference between phase of the replicated signal and the received signal data, \(R(\epsilon)\) is the auto-correlation function defined by Equation~\ref{eq:autocorrelation}, where \(\epsilon \) describes the error in code phase. Finally, \(\eta \) describes unmodeled process noise on each of the correlators.

\begin{equation}\label{eq:autocorrelation}
    R(\epsilon) =
    \begin{cases}
        1 - \vert \epsilon \vert & \epsilon \leq 1 \\
        0                        & \epsilon > 1    \\
    \end{cases}
\end{equation}

\subsection{Discriminators and Loop Filters}
Once the correlators are calculated for a single integration period, discriminators use them to calculate errors in phase, frequency, and code phase. While a number of discriminators exist for each error term, the discriminators presented in this work are the most optimal for low and high carrier-to-noise ratios at the cost of being computationally expensive. Hardware receivers that must work in real-time may use simpler, faster discriminators.

The estimated error in phase is generated using a Costas loop discriminator. It applies an arc-tangent function to the in-phase and quadrature prompt correlators to calculate the error in carrier phase from the most recent replicated signal (Equation~\ref{eq:PLLdisc})

\begin{equation}\label{eq:PLLdisc}
    \phi_{PLL} = \arctan\left(\frac{QP}{IP}\right) \frac{1}{2\pi} \approx \theta_{err} + \eta_{PLL}
\end{equation}

The discriminator is divided by \(2 \pi \) to covert the error from radians to cycles. The Costa discriminator differs from other PLL discriminators as it is immune to bit integers on the data inverting. However, in more dynamic scenarios, the FLL discriminator may be more heavily relied upon as the Costas discriminator due to its high sensitivity.

The FLL discriminator derives its error by analyzing the change in carrier phase error across a single integration period

\begin{equation}\label{eq:FLLdisc}
    \phi_{FLL} = \arctan2\left(cross,dot\right) \, \frac{1}{2\pi \,T} \approx f_{err} + \eta_{FLL},
\end{equation}
where
\begin{equation}\label{eq:crossdot}
    \begin{split}
        cross & = IP_1\,QP_2 - IP_2\,QP_1\\
        dot & = IP_1\,IP_2 + QP_1\,QP_2. \\
    \end{split}
\end{equation}
Conventionally, \({\left(IP,QP\right)}_1\) are correlators in the middle of the integration period. The FLL discriminator is not as sensitive to dynamic stress and can handle changes in frequencies up to 500 Hertz.

The code phase error is determined using a DLL discriminator. It takes the early and late correlators that are shifted by a constant chip spacing, \(d\), to determine if the current replicated signal is advanced or delayed relative to the received signal data. Equation~\ref{eq:DLLdisc} describes the DLL discriminator utilized in this work.

\begin{equation}\label{eq:DLLdisc}
    \phi_{DLL} = \frac{\sqrt{IE^2 + QE^2} - \sqrt{IL^2 + QL^2}}{2 \sqrt{IE^2 + QE^2} + \sqrt{IL^2 + QL^2}} \approx \epsilon + \eta_{DLL}
\end{equation}

The DLL discriminator produces code phase errors within \(\frac{1}{2}\) chips, but becomes unstable if the correlator errors are greater than \(\frac{3}{2}\) chips from the true code phase. This is allowable as errors of this magnitude are beyond the linear pull-in range of the DLL loop filter.

For scalar tracking, loop filters apply the errors aforementioned to more accurately replicate the signal for the next integration period. For this work, a second-order PLL with a first-order FLL assist is used to tracking changes in carrier frequency and phase (Figure~\ref{fig:PLL}).

\begin{figure}[!ht]\label{fig:PLL}
    \centering
    \includegraphics[width=\linewidth]{Figures/PLL.png}
    \caption{Discrete block diagram of the PLL-FLL loop filters used in this work.}
\end{figure}

The natural-radian frequency, \(\omega_0\), is set by the user, and common values for processing GPS L1 C/A exists in~\cite{kaplanUnderstandingGPSPrinciples2006}.

The DLL loop filter works in a similar fashion, but without the FLL loop filter assist and the addition of the output of the PLL-FLL loop filter to aid in replicating the true code phase (Figure~\ref{fig:DLL}).

\begin{figure}[!ht]\label{fig:DLL}
    \centering
    \includegraphics[width=\linewidth]{Figures/DLL.png}
    \caption{Discrete block diagram of the DLL loop filter used in this work.}
\end{figure}

In Figure~\ref{fig:DLL}, \(sf\) is known as the scale factor,
\begin{equation}\label{eq:sf}
    sf = \frac{R_c}{f_L},
\end{equation}

where \(R_c\) is the spreading code rate, and \(f_L\) is the signal carrier frequency. For GPS L1 C/A, these are \(1.023 \times 10^6\) and \(1575.420 \times 10^6\), respectively.

If the correlators, discriminators, and loop filters are correctly working in tandem, the replicated signal should accurately represent the received signal data and the receiver can decode the bits that translate to the broadcast navigation message from each satellite. A handful of subframes in the navigation message provide satellite ephemeris, or orbital parameters, that the receiver can use to propagate satellite PVT and determine its position through time.

\section{Navigation Algorithms}
Once the signal is accurately replicated and correctly decoded, the receiver begins to estimate a PVT solution. A position solution is found due to trilateration, meaning if there exists at least three unique ranges from known locations, than a position solution exists. Parallel to finding the position solution, receiver velocity can be found in the same way, except this time, using range rates. This sections describes calculating the ranges and range rates, and how they are used in the navigation processor for an estimated PVT solution.

\subsection{GPS Measurements}
There exists three main measurements from GPS satellites. The first of the three is pseudorange. By definition, it is the total time of transit from transmission to reception of the signal by the receiver. This value is then multiplied by the speed of light, providing this transit time in units of meters (Equation~\ref{eq:psr_time}).

\begin{equation}\label{eq:psr_time}
    \tilde{\rho}^j = (t_r - t_t^j)\,c
\end{equation}

In order to calculate a pseudorange, \(\rho \), from the \(j^{th}\) satellite The transmitted time of the signal, \(t_t\), is subtracted from the received time, \(t_r\), and then multiplied by the speed of light in vacuum, \(c\), as described before. For the rest of the work presented in this thesis, variables with \(\tilde{}\) represent a measurement. The pseudorange from Equation~\ref{eq:psr_time} is a measurement because both the receiver clock and satellite clock have inherit biases and drifts that perturb their values from their truth. In addition to the errors in the clocks, the signal in space travels through the atmosphere, delaying the signal until it reaches the receiver. We can change Equation~\ref{eq:psr_time} such that these errors and delays are modeled. Describing the pseudorange in meters gives us,

\begin{equation}\label{eq:psr_meters}
    \tilde{\rho}^j = r_u^j + c\,t^j + c\,t_u + I^i_u + T^i_u+ M^i_u + \eta^i_{\rho},
\end{equation}
where,
\begin{equation}\label{eq:range_meters}
    r^j_u = \sqrt{{\left(x^j - x_u\right)}^2 + {\left(y^j - y_u\right)}^2 + {\left(z^j - z_u\right)}^2},
\end{equation}

\(t_u\) is the clock bias of the user, \(t^j\) is the clock bias of the \(j^{th}\) satellite, \(I\) is the ionospheric delay, \(T\) is the tropospheric delay, \(M\) is the delay of multipath, and \(\eta \) is additive Gaussian white noise all at time \(i\).

Positioning with GPS is possible because of the atomic clocks on board of each satellite. These clocks are highly stable and allow the Time of Week (TOW) to be transmitted in the data message for which the receiver decodes. Although the on board clocks are incredibly stable, the PRN sequence cannot be precisely transmitted at every millisecond. Fortunately, these clock errors are modeled in the data message, so \(t^j\) can be removed from the pseudorange equation. Clocks on board receivers are not quite as stable, and the received time of the signal is not known upon a cold start. A solution to this problem is initialize the received time to the first satellite transmit time and add a nominal offset of \(66.7\) milliseconds. This offset stems from back of the envelope calculation based on the distance between MEO satellite orbits and the center of the Earth (Equation~\ref{eq:nominalOffset}).

\begin{equation}\label{eq:nominalOffset}
    {\left(t_u - t^{j} \right)}^{i = 0} = \frac{d_{MEO}}{c} \approx \frac{20000000}{299792458} \approx 0.0667
\end{equation}

The addition of the unknown receiver clock bias adds a fourth dimension to the trilateration position solution. This effectively requires that the receiver needs the ranges from four satellites to estimate \(x_u\), \(y_u\), \(z_u\), and \(t_u\).

The second measurement from GPS satellites is pseudorange-rate. By definition, pseudorange-rate is the measurement of the line of sight velocity that can be directly derived from changes in carrier frequency, also known as the Doppler frequency (Equation~\ref{eq:psrdot_time}).

\begin{equation}\label{eq:psrdot_time}
    \tilde{\dot{\rho}} = - \frac{\left(f_c - f_{IF}\right)\,c}{f_t}
\end{equation}

Above, \(f_c\) is the estimated frequency of the carrier wave, \(f_{IF}\) is the receiver intermediate frequency, and \(f_t\) is the nominal transmit frequency. Another way to represent pseudorange-rate measurement is by deriving Equation~\ref{eq:psr_meters} with respect to time. This geometric representation is seen in Equation~\ref{eq:psrdot_meters}.

\begin{equation}\label{eq:psrdot_meters}
    \tilde{\dot{\rho}} = \dot{r}_u^j + c\,\dot{t}_u + \dot{I}^i_u + \dot{T}^i_u + \eta^i_{\dot{\rho}}
\end{equation}

From Equation~\ref{eq:psrdot_meters}, it is assumed that the atomic clocks on board the satellites are stable enough such that the clock drift term is \(0\). The same can be said for \(\dot{M}^i_u\) where the error-rate due to multipath is miniscule.

Similar to the pseudorange measurement, if the receiver clock was perfect, only three satellites would be needed to measure pseudorange-rate. However, because of the instability in the receiver clock, the drift biases the frequencies. Therefore, four pseudorange-rate are still required in order to calculate receiver velocities.

The last measurement from GPS satellites is estimate of noise on a signal. The receiver utilizes a Carrier-to-Noise density ratio (\(C/N_0\)) to determine the quality of pseudorange and pseudorange-rate measurements from each satellite. Equation~\ref{eq:CN0} demonstrates how \(C/N_0\) is calculated in this work.

\begin{equation}\label{eq:CN0}
    \frac{C}{N_0} = 10\,\log_{10} {\left(\frac{\tilde{A} - 4\hat{\sigma_{eta}^2}}{2\,T\hat{\sigma_{eta}^2}}\right)}
\end{equation}

Where,

\begin{equation}\label{eq:ampitude}
\tilde{A} = {\left(IE +IL\right)}^2 + {\left(QE + QL\right)}^2
\end{equation}

is the measured power of the accurately tracked signal using correlators defined in a previous section.\(\sigma_{eta}^2\) is the variance in correlators that are the result of a shifting the replicated signal far outside of any correlation with the data of the received signal data. This work shifts these correlators by \(100\),\(200\), \(300\) chips each. Furthermore, this variance is filtered with a moving average using a ratio of \(99:1\) between the current calculated variance and the previous filtered variance. Shifting the replicated signal by a large number of chip and then correlating the shifted signal with the received signal data is computationally expensive, but is necessary if using a Bayesian estimator or weighted least squares approach in both open-loop and vector tracking navigation algorithms. 


\subsection{Open-Loop Architectures}
\subsection{Vector Tracking}

\section{Conclusions}